<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yifan Xia | Designer & Strategist</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background-color: #ffffff; 
            cursor: grab;
        }
        body:active { cursor: grabbing; }
        canvas { display: block; }
    </style>
</head>
<body>

<script>
/**
 * YIFAN XIA - INTERACTIVE CANVAS RESUME
 * Optimized for click bursts and draggable career nodes.
 */

let driftParticles = [];
let nodes = [];
let mouseTrail = [];
let clickBursts = [];
let colorIndex = 0;
const palette = ['#4285F4', '#EA4335', '#FBBC05', '#34A853'];
const phrases = [
  'Parsons BFA', 
  'Central Saint Martins', 
  'Vanderbilt MMark', 
  '3 languages', 
  'motion graphics', 
  'brand identity', 
  'maker + strategist'
];

function setup() {
  // Canvas now receives all mouse events normally
  createCanvas(windowWidth, windowHeight);

  // Background ambient particles
  for (let i = 0; i < 40; i++) {
    driftParticles.push(new DriftParticle());
  }
  
  // Interactive text nodes
  for (let i = 0; i < phrases.length; i++) {
    nodes.push(new FloatingNode(phrases[i]));
  }
  
  textFont('Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif');
}

function draw() {
  background(255); // Solid white, no trails

  handleCursorStyling();

  // 1. Mouse Trail (Drawing while moving)
  if (mouseX !== pmouseX || mouseY !== pmouseY) {
    let activeColor = palette[colorIndex % palette.length];
    mouseTrail.push(new TrailPoint(mouseX, mouseY, activeColor));
    colorIndex++;
  }
  updateAndDisplay(mouseTrail, 30);

  // 2. Click Bursts (Active feedback)
  updateAndDisplay(clickBursts, 100);

  // 3. Background Drift
  driftParticles.forEach(p => {
    p.update();
    p.display();
  });
  
  // 4. Draggable Resume Nodes
  nodes.forEach(n => {
    n.update();
    n.display();
  });

  // 5. Static Brand Identity & Contact
  drawIdentity();
  drawContact();
}

function updateAndDisplay(arr, max) {
  for (let i = arr.length - 1; i >= 0; i--) {
    arr[i].update();
    arr[i].display();
    if (arr[i].isDead() || arr.length > max) {
      arr.splice(i, 1);
    }
  }
}

function handleCursorStyling() {
  // Center protection zone
  let overCenter = (mouseX > width/2 - 150 && mouseX < width/2 + 150 &&
                    mouseY > height/2 - 40 && mouseY < height/2 + 40);
  
  let overNode = false;
  for (let n of nodes) {
    if (n.isMouseOver()) { overNode = true; break; }
  }

  if (overCenter) {
    cursor(ARROW);
  } else if (overNode || mouseIsPressed) {
    cursor('grabbing');
  } else {
    cursor('grab');
  }
}

function drawIdentity() {
  push();
  textAlign(CENTER, CENTER);
  noStroke();
  fill(40);
  textSize(32);
  textStyle(BOLD);
  text("YIFAN XIA", width / 2, height / 2 - 15);
  
  fill(160);
  textSize(13);
  textStyle(NORMAL);
  text("D E S I G N E R  +  S T R A T E G I S T", width / 2, height / 2 + 20);
  pop();
}

function drawContact() {
  push();
  textAlign(RIGHT, BOTTOM);
  noStroke();
  fill(40); 
  textSize(11);
  textStyle(NORMAL);
  // Elegant spaced formatting
  let email = "Y I F A N . X I A @ V A N D E R B I L T . E D U";
  text(email, width - 40, height - 40);
  pop();
}

function mousePressed() {
  let hitAny = false;
  
  // Check if we are clicking a word
  for (let i = nodes.length - 1; i >= 0; i--) {
    if (nodes[i].isMouseOver()) {
      nodes[i].dragging = true;
      nodes[i].offsetX = nodes[i].pos.x - mouseX;
      nodes[i].offsetY = nodes[i].pos.y - mouseY;
      hitAny = true;
      break; 
    }
  }

  // If clicking white space, trigger the burst
  if (!hitAny) {
    for (let i = 0; i < 8; i++) {
      let col = palette[Math.floor(random(palette.length))];
      clickBursts.push(new BurstParticle(mouseX, mouseY, col));
    }
  }
}

function mouseReleased() {
  nodes.forEach(n => n.dragging = false);
}

class DriftParticle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = createVector(random(-0.1, 0.1), random(-0.1, 0.1));
    this.size = random(4, 10); 
    this.color = color(random(palette));
    this.color.setAlpha(70);
  }
  update() {
    this.pos.add(this.vel);
    if (this.pos.x < 0 || this.pos.x > width) this.vel.x *= -1;
    if (this.pos.y < 0 || this.pos.y > height) this.vel.y *= -1;
  }
  display() {
    noStroke();
    fill(this.color);
    ellipse(this.pos.x, this.pos.y, this.size);
  }
}

class FloatingNode {
  constructor(txt) {
    this.txt = txt;
    this.pos = createVector(random(150, width-150), random(150, height-150));
    this.vel = createVector(random(-0.05, 0.05), random(-0.05, 0.05));
    this.noiseOffset = random(1000);
    this.dragging = false;
    this.hitboxW = 120; 
    this.hitboxH = 40; 
  }
  isMouseOver() {
    return (mouseX > this.pos.x - this.hitboxW/2 && mouseX < this.pos.x + this.hitboxW/2 &&
            mouseY > this.pos.y - this.hitboxH/2 && mouseY < this.pos.y + this.hitboxH/2);
  }
  update() {
    if (this.dragging) {
      this.pos.x = mouseX + this.offsetX;
      this.pos.y = mouseY + this.offsetY;
    } else {
      let n = noise(this.noiseOffset + frameCount * 0.001);
      this.pos.x += map(n, 0, 1, -0.07, 0.07);
      this.pos.add(this.vel);
      if (this.pos.x < -100) this.
